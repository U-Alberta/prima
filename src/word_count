#!/usr/bin/python
import linecache
import nltk.tokenize
from nltk.tokenize import sent_tokenize, word_tokenize
import os
import sqlite3
import sys

# If the user gave something higher than a line, iterate through objects and 
# call the next lower function (collection calls item which calls file which 
# calls line).
def count_collection(path):
	n = 0
	for doc_path in os.listdir(path):
		n+=count_item(path+"/"+doc_path)
	return n

def count_item(path):
	n = 0
	for doc_path in os.listdir(path):
		n+=count_file(path+"/"+doc_path)
	return n

def count_file(path):
	n = 0
	doc = open(path, "r")
	for line in doc:
		n+=count_line(line)
	doc.close()
	return n

# When line is called, tokenize, remove symbols and count the words.
def count_line(line):
  punc = {".":0, ",":0, ";":0, ":":0, "!":0, "?":0, "-":0, "_":0, "'":0, \
  	'"':0, "'s":0}
  n = 0
  sentence_list = sent_tokenize(line.decode("utf-8"))
  for sentence in sentence_list:
    for term in word_tokenize(sentence):
      if term not in punc:
        n+=1
  return n

# With the path given, create a unique file name for each line, file, item, 
# and collection possible. If the directory word_count doesn't exist, create 
# it so we can add the output file to it later.
def name_outfile(path):
	path = path.split("/")
	clean_path = []
	for directory in path:
		directory = directory.split("_")
		directory = "".join(directory)
		directory = directory.split(".")[0]
		if len(clean_path) == 3:
			directory = "line"+directory
		clean_path.append(directory)
	outfile = "_".join(clean_path)
	outfile = "processed/word_count/"+outfile
	if not os.path.exists("processed/word_count/"):
		os.makedirs("processed/word_count")
	return outfile

def insert_to_db(command, output):
	line = (command, output,)
	conn = sqlite3.connect("processed/hist.db")
	c = conn.cursor()
	c.execute("INSERT INTO History VALUES(?,?)", line)
	conn.commit()
	conn.close()
	return 1

def word_count():
	if len(sys.argv) != 2:
		print("Invalid number of command line arguments")
		return -1
	command = sys.argv[1]
	path = command
	depth = len(path.split("/"))
	# Depending on the path given by the user (to a collection, item, etc), 
	# compute n.
	if (depth == 1) or (depth == 2 and path.split("/")[-1] == ""):
		if depth == 2:	path = path.strip("/")
		try:
			n = count_collection(path)
		except:
			print("Error counting words in collection {}".format(command))
			return -1
	elif (depth == 2) or (depth == 3 and path.split("/")[-1] == ""):
		if depth == 3:	path = path.strip("/")
		try:
			n = count_item(path)
		except:
			print("Error counting words in item {}".format(command))
			return -1
	elif (depth == 3) or (depth == 4 and path.split("/")[-1] == ""):
		if depth == 4:	path = path.strip("/")
		try:
			n = count_file(path)
		except:
			print("Error counting words in file {}".format(command))
			return -1
	elif (depth == 4) or (depth == 5 and path.split("/")[-1] == ""):
		if depth == 5:	path = path.strip("/")
		try:
			lineno = int(path.split("/")[-1])
			tmp = path.split("/")[:-1]
			newpath = "/".join(tmp)
			line = linecache.getline(newpath, lineno)
		except:
			print("Invalid path given")
			return -1
		try:
			n = count_line(line)
		except:
			print("Error counting words in line {} of {}".format(lineno, newpath))
			return -1
	else:
		print("Invalid path depth")
		return -1
	# Once n has been sucessfully computed, create a file in the appropriate 
	# place (name_outfile) and save the value of n in there.
	try:
		output = str(n)
		command = "word_count "+sys.argv[1]
		outfilename = name_outfile(path)
		outfile = open(outfilename, "w")
		outfile.write(output)
		outfile.close()
	except:
		print("Error saving result to file")
		return -1
	try:
		insert_to_db(command, output)
	except:
		print("Error saving to history database")
		return -1
	return 1

word_count()